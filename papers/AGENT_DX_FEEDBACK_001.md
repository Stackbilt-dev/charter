---
title: "Agent DX Feedback: Codex Lockfile Archaeology"
feedback-id: ADX-001
date: 2026-02-26
source: "Codex (OpenAI) working on edgestack_v2"
severity: high
related:
  - CSA-002 (evidence of the problem ADF solves)
  - ARCHITECT_V2_INTEGRATION_BRIEF (scaffold should prevent this)
---

# Agent DX Feedback: Codex Lockfile Archaeology

## Observation

An OpenAI Codex agent attempted to understand Charter's `.adf.lock` schema
by exploring `node_modules/@stackbilt/cli`. The agent:

1. Read the full README (289 lines) â€” truncated by the tool interface
2. Found `loadLockFile` via ripgrep at line 430 of compiled `adf.js`
3. Dumped the entire 759-line compiled JS â€” truncated again
4. Got stuck in a loop of incomplete information, never reaching the schema

The lockfile format is trivially simple:

```json
{ "core.adf": "54d5c9a146d6da3c" }
```

A flat JSON map of `filename â†’ sha256-prefix(16)`. The agent spent hundreds
of tokens and multiple tool calls to not-quite-discover this.

## Root Causes

### 1. Schema is undocumented
The `.adf.lock` format exists only in implementation code (`adf.ts:538-544`).
No TypeScript type is exported. No docs page describes it. No `--explain`
flag outputs the schema.

### 2. No `.d.ts` breadcrumb
The compiled `adf.js` in `dist/` is what agents see in `node_modules`.
While `.d.ts` files are shipped, the lockfile interfaces (`AdfSyncResult`,
`SyncStatus`) are internal to the CLI command handler â€” not exported from
the `@stackbilt/adf` package API.

### 3. Agent lacked ADF context
If the project had `.ai/` set up with ADF development context, the agent
would have received the lockfile format from a triggered module rather than
reverse-engineering compiled output. This is the exact scenario ADF prevents.

### 4. Tool truncation is opaque
The agent's tool interface truncated file reads with `â€¦ +759 lines` but
provided no recovery guidance (e.g., "use line ranges to page through").

## Impact on CSA-002

This transcript is real-world evidence of the "without ADF" cost:

| Metric | With ADF (projected) | Without ADF (observed) |
|---|---|---|
| Tokens to discover lockfile schema | ~80 (one ADF section) | 500+ (multiple truncated reads) |
| Tool calls | 0 (context already loaded) | 6+ (search â†’ read â†’ truncate â†’ retry) |
| Time | 0 (immediate) | Minutes of archaeology |
| Success | Guaranteed (schema in context) | Partial (never fully extracted) |

This data point should be captured in CSA-002 Section 2.4 (ADF Routing
Effectiveness) as a qualitative baseline for the "without governance" case.

## Recommended Charter Improvements

### P0: Document the lockfile schema

Add to the `@stackbilt/adf` package README and the docs site CLI reference:

```
### .adf.lock Format

A flat JSON object mapping ADF source filenames to truncated SHA-256 hashes:

    { "<filename>.adf": "<sha256-hex-prefix-16>" }

Generated by `charter adf sync --write`. Checked by `charter adf sync --check`.
Hash is the first 16 hex characters of SHA-256 of the source file content.
```

### P1: Export lockfile types from @stackbilt/adf

Move the sync interfaces to the `@stackbilt/adf` public API so agents
reading `.d.ts` files in `node_modules` find them:

```typescript
export interface AdfLockfile {
  [sourceFile: string]: string; // sha256 hex prefix (16 chars)
}

export interface AdfSyncEntry {
  source: string;
  sourceHash: string;
  lockedHash: string | null;
  inSync: boolean;
}
```

### P2: Add `charter adf sync --explain`

Output the lockfile schema in machine-readable format:

```bash
charter adf sync --explain --format json
# { "format": "json-map", "keyType": "adf-filename", "valueType": "sha256-hex-16", "example": { "core.adf": "54d5c9a146d6da3c" } }
```

### P3: Add lockfile context to adf-dev.adf

Update `.ai/adf-dev.adf` to include the lockfile schema so any agent
working on Charter's own ADF code gets it automatically:

```
ðŸ“‹ CONTEXT:
  - Lockfile: .adf.lock is a flat JSON map { "file.adf": "sha256-prefix-16" }
  - Hash: crypto.createHash('sha256').update(content).digest('hex').slice(0, 16)
  - Sync logic lives in packages/cli/src/commands/adf.ts (loadLockFile, hashSource)
```

### P4: Scaffold emits documented .adf.lock

When Architect v2 scaffold generates `.ai/`, it should also generate
the initial `.adf.lock` so `charter adf sync --check` passes on first
CI run (per ARCHITECT_V2_INTEGRATION_BRIEF question #3).
